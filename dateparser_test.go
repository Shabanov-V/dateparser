package dateparser

import (
    "fmt"
    "time"
    "testing"
    assert "github.com/stretchr/testify/require"
)

var tests = []struct{s string; e string}{
    {   // date command reversed
        "Thu Sep 25 10:36:28 MST 2003",
        "2003-09-25 10:36:28 -0700 MST",
    },
    {   // date command reversed
        "Thu Sep 25 10:36:28 MST 2003",
        "2003-09-25 10:36:28 -0700 MST",
    },
    {   // date command stripped timezone
        "Thu Sep 25 10:36:28 2003",
        "2003-09-25 10:36:28 +0000 UTC",
    },
    {   // date command stripped year
        "Thu Sep 25 10:36:28",
        "2006-09-25 10:36:28 +0000 UTC",
    },
    {   // date command stripped day
        "Thu Sep 10:36:28",
        "2006-09-02 10:36:28 +0000 UTC",
    },
    {   // date command stripped month
        "Thu 10:36:28",
        "2006-01-02 10:36:28 +0000 UTC",
    },
    {   // date command stripped weekday
        "Sep 10:36:28",
        "2006-09-02 10:36:28 +0000 UTC",
    },
    {   // date command only time
        "10:36:28",
        "2006-01-02 10:36:28 +0000 UTC",
    },
    {   // date command only time stripped seconds
        "10:36",
        "2006-01-02 10:36:05 +0000 UTC",
    },
    {   // date command only date
        "Thu Sep 25 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {   // date command only date stripped weekday
        "Sep 25 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {   // date command only date stripped day
        "Sep 2003",
        "2003-09-02 15:04:05 +0000 UTC",
    },
    {   // month only
        "Sep",
        "2006-09-02 15:04:05 +0000 UTC",
    },
    {   // year only
        "2003",
        "2003-01-02 15:04:05 +0000 UTC",
    },
    {   // date command R format
        "Thu, 25 Sep 2003 10:49:41 -0300",
        "2003-09-25 10:49:41 +0000 UTC",
    },
    {   // ISO-8601
        "2003-09-25T10:49:41-03:00", // TODO: 41.5
        "2003-09-25 10:49:41 -0300 -0300",
    },
    {   // ISO-8601 stripped timezone
        "2003-09-25T10:49:41",
        "2003-09-25 10:49:41 +0000 UTC",
    },
    {   // ISO-8601 stripped seconds
        "2003-09-25T10:49",
        "2003-09-25 10:49:05 +0000 UTC",
    },
    {   // ISO-8601 stripped minutes
        "2003-09-25T10",
        "2003-09-25 10:04:05 +0000 UTC",
    },
    {   // ISO-8601 stripped hours
        "2003-09-25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {   // Python Logger
        "2003-09-25 10:49:41,502", // TODO:
        "2003-09-25 10:49:41 +0000 UTC",
    },
    {   // dashed date
        "2003-09-25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {   // dashed date with named month
        "2003-Sep-25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "Sep-25-2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "09-25-2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25-09-2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "10-09-2003",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "10-09-03",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "2003.09.25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "2003.Sep.25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25.Sep.2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "Sep.25.2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "09.25.2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25.09.2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "10.09.2003",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "10.09.03",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "2003/09/25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "2003/Sep/25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25/Sep/2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "Sep/25/2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "09/25/2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25/09/2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "10/09/2003",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "10/09/03",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "2003 09 25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "2003 Sep 25",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25 Sep 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "Sep 25 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "09 25 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "25 09 2003",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    {
        "10 09 2003",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "10 09 03",
        "2003-09-10 15:04:05 +0000 UTC",
    },
    {
        "25 09 03",
        "2003-09-25 15:04:05 +0000 UTC",
    },
    // {
    //     "03 25 Sep",
    //     "&{03 09 25      }",
    // },
    {
        "10h36m28s",
        "2006-01-02 10:36:28 +0000 UTC",
    },
    {
        "10h36m",
        "2006-01-02 10:36:05 +0000 UTC",
    },
    {
        "10h",
        "2006-01-02 10:04:05 +0000 UTC",
    },
    {
        "10:00 am",
        "2006-01-02 10:04:05 +0000 UTC",
    },
    {
        "10:00 pm",
        "2006-01-02 22:04:05 +0000 UTC",
    },
}

func TestParse(t *testing.T) {
    def := time.Date(2006, 01, 02, 15, 04, 05, 0, time.UTC)
    for _, test := range tests {
        v := fmt.Sprint(Parse([]byte(test.s), &def))
        fmt.Println("Parse=", test.s, "Result=", v)
        assert.Equal(t, test.e, v)
    }
}

